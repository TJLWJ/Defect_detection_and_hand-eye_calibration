// CDlg11.cpp: 实现文件
//

#include "stdafx.h"
#include "ProjectOne.h"
#include "CDlg11.h"
#include "afxdialogex.h"


// CDlg11 对话框

IMPLEMENT_DYNAMIC(CDlg11, CDialogEx)

CDlg11::CDlg11(CWnd* pParent /*=nullptr*/)
	: CDialogEx(IDD_Dlg11, pParent)
{
	m_strEditReceiveMsg = _T("");
	m_strEditSendMsg = _T("");
	m_bSerialPortOpened = FALSE;
	m_CurrentCircle=0;
	m_CurrentPos = 0;
	m_AbsPos = 0;
	m_PulsePerS = 0;
	m_mmPerS = 0;
	isContinueReading = false;
	startVelocityMes = false;
	btn_select = 0;
	m_PreviousPos = 0;
}

CDlg11::~CDlg11()
{
}

void CDlg11::DoDataExchange(CDataExchange* pDX)
{

	DDX_Control(pDX, IDC_COMBO_COMSELECT, m_ctrlComboComport);
	DDX_Text(pDX, IDC_RECEIVEMSG1, m_strEditReceiveMsg);
	DDX_Text(pDX, IDC_SENDMSG1, m_strEditSendMsg);


	DDX_Text(pDX, IDC_EDIT1, m_CurrentCircle);
	DDX_Text(pDX, IDC_EDIT2, m_CurrentPos);
	DDX_Text(pDX, IDC_EDIT3, m_AbsPos);
	DDX_Text(pDX, IDC_EDIT4, m_PulsePerS);
	DDX_Text(pDX, IDC_EDIT44, m_mmPerS);



	CDialogEx::DoDataExchange(pDX);
}


BEGIN_MESSAGE_MAP(CDlg11, CDialogEx)
	ON_MESSAGE(WM_COMM_RXCHAR, OnComm)
	ON_BN_CLICKED(IDC_OPEN_COMPORT, &CDlg11::OnBnClickedOpenComport)
	ON_BN_CLICKED(IDC_CLOSE_COMPORT, &CDlg11::OnBnClickedCloseComport)
	ON_BN_CLICKED(IDC_BUTTON_SEND, &CDlg11::OnBnClickedButtonSend)
END_MESSAGE_MAP()


// CDlg11 消息处理程序





///真正的发送数据区域
void  CDlg11::SendCommand(CString strCommand)
{
	if (!m_bSerialPortOpened) return;

	//-----清空之前收到的信息 --------//
		//UpdateData(TRUE);
		//m_strEditReceiveMsg = "";//清空之前接收到的PLC回文
		//UpdateData(FALSE);

	char m_hexCommand[128];
	int len = Str2Hex(strCommand, m_hexCommand);//字符串转换为十六进制

	unsigned char m_uCharCommand[128];//十六进制转换为无符号数
	for (int i = 0; i < len; i++)
	{
		m_uCharCommand[i] = m_hexCommand[i];
	}

	unsigned short crc = CRC_Modbus(m_uCharCommand, len);//计算CRC-Modbus校验码

	m_hexCommand[len] = crc / 256;//给待发送的数据加上CRC校验码
	m_hexCommand[len + 1] = crc % 256;

	//-----发送16进制川所用到的 --------//
	//	m_SerialPort.WriteToPort(m_hexCommand, len + 2);//发送给PLC串口


	//发送文字时用的，发送16进制请将其注释------//  
	char bigbang[128];
	for (int i = 0; i < strCommand.GetLength(); i++)
	{
		bigbang[i] = strCommand[i];
	}
	m_SerialPort.WriteToPort(bigbang, strCommand.GetLength());
	GetDlgItem(IDC_SENDMSG1)->SetWindowText(_T("")); //sendCommand 清空
	m_strEditSendMsg = "";
}


///将发送区中的字符转换为十六进制数
int  CDlg11::Str2Hex(CString str, char *senddata)
{
	int hexdata, lowhexdata;
	int hexdatalen = 0;
	int len = str.GetLength();

	for (int i = 0; i < len;)
	{
		char lstr, hstr = str[i];
		if (hstr == ' ')
		{
			i++;
			continue;
		}
		i++;
		if (i >= len)
			break;
		lstr = str[i];
		hexdata = HexChar(hstr);
		lowhexdata = HexChar(lstr);
		if ((hexdata == 16) || (lowhexdata == 16))
			break;
		else
			hexdata = hexdata * 16 + lowhexdata;
		i++;
		senddata[hexdatalen] = (char)hexdata;
		hexdatalen++;
	}
	return hexdatalen;
}


///将0-F字符转换为相应的十进制数
char   CDlg11::HexChar(char c)
{
	if ((c >= '0') && (c <= '9'))
		return c - 0x30;
	else if ((c >= 'A') && (c <= 'F'))
		return c - 'A' + 10;
	else if ((c >= 'a') && (c <= 'f'))
		return c - 'a' + 10;
	else
		return 0x10;
}




const unsigned char m_auchCRCHi[] =
{
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40,
	0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1,
	0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
	0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
	0x80, 0x41, 0x00, 0xC1, 0x81, 0x40
};

const unsigned char m_auchCRCLo[] =
{
	0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06,
	0x07, 0xC7, 0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD,
	0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
	0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A,
	0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC, 0x14, 0xD4,
	0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
	0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3,
	0xF2, 0x32, 0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4,
	0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
	0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29,
	0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF, 0x2D, 0xED,
	0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
	0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60,
	0x61, 0xA1, 0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67,
	0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
	0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68,
	0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA, 0xBE, 0x7E,
	0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
	0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71,
	0x70, 0xB0, 0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92,
	0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
	0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B,
	0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89, 0x4B, 0x8B,
	0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
	0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42,
	0x43, 0x83, 0x41, 0x81, 0x80, 0x40
};

///计算CRC_ModBus 校验码
unsigned short  CDlg11::CRC_Modbus(unsigned char *puchMsg, unsigned short usDataLen)
{
	unsigned char uchCRCHi = 0xFF;
	unsigned char uchCRCLo = 0xFF;
	unsigned short uIndex;

	while (usDataLen--)
	{
		uIndex = uchCRCHi ^ *puchMsg++;
		uchCRCHi = uchCRCLo ^ m_auchCRCHi[uIndex];
		uchCRCLo = m_auchCRCLo[uIndex];
	}
	return(uchCRCHi << 8 | uchCRCLo);
}




void CDlg11::OnBnClickedOpenComport()
{
	if(m_bSerialPortOpened)
		AfxMessageBox(_T("串口已经打开"));

	// TODO: 在此添加控件通知处理程序代码
	int nPort = m_ctrlComboComport.GetCurSel();
	if (nPort < 0) return;

	//波特率9600 ， 8个数据位 ， 1 个停止位 ， 无奇偶校验
	if (m_SerialPort.InitPort(this, nPort, 9600, 'N', 8, 1, EV_RXFLAG | EV_RXCHAR, 512))

		//PLC 中  'E' 为偶校验  ，通讯口默认参数：站号为 1、波特率 19200bps、 8 个数据位、 1 个停止位、偶校验，缓冲区大小为512
	//	if (m_SerialPort.InitPort(this, nPort, 19200, 'E', 8, 1, EV_RXFLAG | EV_RXCHAR, 512))
	{
		m_SerialPort.StartMonitoring();  //启动线程
		m_bSerialPortOpened = TRUE;
	}
	else
	{
		AfxMessageBox(_T("没有发现此串口或被占用"));
		m_bSerialPortOpened = FALSE;
	}

}


void CDlg11::OnBnClickedCloseComport()
{
	// TODO: 在此添加控件通知处理程序代码
	m_SerialPort.ClosePort();
	m_bSerialPortOpened = FALSE;
}


void CDlg11::OnBnClickedButtonSend()
{
	UpdateData(TRUE);
	SendCommand(m_strEditSendMsg);
}



///串口接收消息响应
LRESULT  CDlg11::OnComm(WPARAM ch, LPARAM port)
{
	CString strtemp;
	//将所接收到的十六进制PLC回文转换为字符,普通文字输出
	//strtemp.Format(_T("%c"), ch);   

	//  把strtemp这个变量数据以十六进制的格式输出,如果位数小于2,则左端补0
	strtemp.Format(_T("%02x"), ch);

	m_strEditReceiveMsg += strtemp;

	UpdateData(FALSE);

	if (m_strEditReceiveMsg.GetLength() > 50)   //每行
		m_strEditReceiveMsg = "";


	return 0;
}
